/**
 * 装饰器模式
 * 动态地给一个对象添加一些额外的职责。就增加功能来说，装饰模式相比生成子类更为灵活
 * 优点：
 * 1.相比与静态的继承，装饰器模式正如它定义的，那样可以动态的给一个对象添加额外的职责, 显得更加灵活。静态继承的情况下，
 * 如果要添加其他的功能就需要添加新的子类实现功能，然后相互之间继承，以达到一个组合的功能，对于每一个要添加的功能都要，新建类，显得特别麻烦，也使得系统越来越复杂，
 * 而对于装饰器来说，为一个特定的Component提供多种不同的Decorator，对于一些要达成的功能，相互组合就可以达成目的
 * 2.装饰类和被装饰类可以独立发展，而不会相互耦合
 * 3.装饰模式是继承关系的一个替代方案。我们看装饰类Decorator，不管装饰多少层，返回的对象还是Component，实现的还是is-a的关系
 * 缺点：
 * 对于装饰模式记住一点就足够了：多层的装饰是比较复杂的。为什么会复杂呢？你想想看，就像剥洋葱一样，你剥到了最后才发现是最里层的装饰出现了问题，想象一下工作量吧，
 * 因此，尽量减少装饰类的数量，以便降低系统的复杂度
 */
package code.pattern.decorator;